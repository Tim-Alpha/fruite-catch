<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Fruit Catch</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        touch-action: none; /* Prevent pull-to-refresh on mobile */
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }
      canvas {
        display: block;
      }
      /* Shake animation for bad hits */
      @keyframes shake {
        0% {
          transform: translate(1px, 1px) rotate(0deg);
        }
        10% {
          transform: translate(-1px, -2px) rotate(-1deg);
        }
        20% {
          transform: translate(-3px, 0px) rotate(1deg);
        }
        30% {
          transform: translate(3px, 2px) rotate(0deg);
        }
        40% {
          transform: translate(1px, -1px) rotate(1deg);
        }
        50% {
          transform: translate(-1px, 2px) rotate(-1deg);
        }
        60% {
          transform: translate(-3px, 1px) rotate(0deg);
        }
        70% {
          transform: translate(3px, 1px) rotate(-1deg);
        }
        80% {
          transform: translate(-1px, -1px) rotate(1deg);
        }
        90% {
          transform: translate(1px, 2px) rotate(0deg);
        }
        100% {
          transform: translate(1px, -2px) rotate(-1deg);
        }
      }
      .shake {
        animation: shake 0.5s;
        animation-iteration-count: 1;
      }

      @keyframes float {
  0%, 100% { transform: translateY(0px); }
  50% { transform: translateY(-10px); }
}


@keyframes floatSlow {
  0%, 100% { transform: translateY(0px) translateX(0px); }
  50% { transform: translateY(-5px) translateX(5px); }
}

@keyframes fall {
  0% { transform: translateY(-5px) rotate(0deg); opacity: 0; }
  10% { opacity: 0.6; }
  90% { opacity: 0.6; }
  100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
}
    </style>
  </head>
  <body class="bg-slate-900 text-white select-none">
    <!-- UI Overlay -->
    <div
      id="ui-layer"
      class="absolute inset-0 pointer-events-none flex flex-col justify-between p-4 z-10"
    >
     
      <!-- Top Bar -->
<!-- Top Bar -->
<div class="flex justify-between items-center pointer-events-none">
  <!-- Score -->
  <div class="text-center min-w-[80px]">
    <div
      class="text-4xl font-bold"
      id="score"
      style="
        color: #FFFFFF;
        -webkit-text-stroke: 2px #2D7D32;
        text-shadow: 2px 2px 0 #2D7D32;
        font-family: 'Fredoka One', 'Comic Sans MS', cursive;
      "
    >
      0
    </div>
    <div 
      class="text-xs uppercase tracking-wider font-bold"
      style="color: #2D7D32;"
    >
      Score
    </div>
  </div>

  <!-- Streak (centered) -->
  <div class="flex flex-col items-center flex-1 mx-4">
    <div
      class="text-2xl font-bold"
      id="streak"
      style="
        color: #FFFFFF;
        -webkit-text-stroke: 2px #7B1FA2;
        text-shadow: 2px 2px 0 #7B1FA2;
        font-family: 'Fredoka One', 'Comic Sans MS', cursive;
      "
    >
      x1
    </div>
    <div 
      class="w-full max-w-[120px] h-3 rounded-full mt-1 overflow-hidden"
      style="background: #E0E0E0; box-shadow: inset 0 2px 4px rgba(0,0,0,0.3), 0 2px 0 #BDBDBD;"
    >
      <div
        id="streak-bar"
        class="h-full rounded-full w-0 transition-all duration-300"
        style="background: linear-gradient(180deg, #CE93D8 0%, #9C27B0 100%);"
      ></div>
    </div>
  </div>

  <!-- Lives -->
  <div class="text-center min-w-[80px]">
    <div 
      class="text-2xl" 
      id="lives"
      style="filter: drop-shadow(2px 2px 0 #C62828);"
    >
      ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è
    </div>
    <div 
      class="text-xs uppercase tracking-wider font-bold"
      style="color: #C62828;"
    >
      Lives
    </div>
  </div>
</div>

      <!-- Start Screen -->
<div
id="start-screen"
class="absolute inset-0 pointer-events-auto transition-opacity duration-300"
style="background: linear-gradient(180deg, #7DD3FC 0%, #38BDF8 40%, #22D3EE 100%);"
>
<!-- Add inside start-screen div, before the main content -->
<!-- Clouds -->
<div class="absolute top-10 left-10" style="animation: floatSlow 6s ease-in-out infinite; opacity: 0.9;">
  <span class="text-6xl">‚òÅÔ∏è</span>
</div>
<div class="absolute top-20 right-16" style="animation: floatSlow 6s ease-in-out infinite 1s; opacity: 0.8;">
  <span class="text-5xl">‚òÅÔ∏è</span>
</div>
<div class="absolute top-8 right-1/3" style="animation: floatSlow 6s ease-in-out infinite 2s; opacity: 0.7;">
  <span class="text-4xl">‚òÅÔ∏è</span>
</div>
<div class="absolute top-32 left-1/4" style="animation: floatSlow 6s ease-in-out infinite 3s; opacity: 0.85;">
  <span class="text-5xl">‚òÅÔ∏è</span>
</div>
<!-- Ground/grass at bottom -->
<div class="absolute bottom-0 left-0 right-0 h-32" style="background: linear-gradient(180deg, #4ADE80 0%, #22C55E 50%, #16A34A 100%); border-radius: 50% 50% 0 0 / 30px 30px 0 0;"></div>

<div class="absolute inset-0 flex flex-col items-center justify-center z-10">
  
  <!-- Title -->
  <h1 
    class="text-6xl md:text-7xl tracking-wider mb-1 font-bold"
    style="
      font-family: 'Fredoka One', 'Comic Sans MS', cursive;
      color: #FEF3C7;
      text-shadow: 3px 3px 0 #8B4513, 4px 4px 0 #5D3A1A, 0 6px 10px rgba(0,0,0,0.3);
    "
  >CATCH</h1>
  <h2 
    class="text-5xl md:text-6xl tracking-wide mb-10 font-bold"
    style="
      font-family: 'Fredoka One', 'Comic Sans MS', cursive;
      color: #FFFFFF;
      text-shadow: 3px 3px 0 #8B4513, 4px 4px 0 #5D3A1A, 0 6px 10px rgba(0,0,0,0.3);
    "
  >THE FRUIT</h2>
  
  <!-- Button Area with Floating Fruits -->
  <div class="relative flex flex-col items-center">
    
    <!-- Floating Fruits Around Button -->
    <div class="absolute -left-16 -top-4" style="animation: float 3s ease-in-out infinite; filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.2));">
      <span class="text-5xl">üçé</span>
    </div>
    <div class="absolute -right-16 -top-4" style="animation: float 3s ease-in-out infinite 0.5s; filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.2));">
      <span class="text-5xl">üçá</span>
    </div>
    <div class="absolute -left-12 top-12" style="animation: float 3s ease-in-out infinite 1s; filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.2));">
      <span class="text-4xl">üçä</span>
    </div>
    <div class="absolute -right-10 top-14" style="animation: float 3s ease-in-out infinite 1.5s; filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.2));">
      <span class="text-4xl">üçì</span>
    </div>
    
    <!-- Play Button -->
    <button
      id="start-btn"
      class="px-10 py-4 rounded-full text-2xl font-bold text-white tracking-wide cursor-pointer transition-all duration-150 hover:-translate-y-0.5 active:translate-y-1"
      style="
        background: linear-gradient(180deg, #4ADE80 0%, #22C55E 50%, #16A34A 100%);
        box-shadow: 0 6px 0 #15803D, 0 8px 15px rgba(0,0,0,0.3), inset 0 2px 4px rgba(255,255,255,0.4);
        text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
      "
    >
      Play Now
    </button>
    
    <!-- Instructions -->
    <p class="mt-5 text-sm font-semibold" style="color: #475569; text-shadow: 0 1px 2px rgba(255,255,255,0.8);">
      Use Arrow Keys / A-D or Drag to move
    </p>
  </div>
  
  <!-- Basket Canvas -->
  
</div>
<!-- Basket anchored near bottom -->
<div class="absolute bottom-24 left-0 right-0 flex justify-center z-10 pointer-events-none">
  <canvas
    id="start-basket"
    width="150"
    height="100"
    style="filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));"
  ></canvas>
</div>
</div>
 
        </div>
      </div>

      <!-- Game Over Screen -->
      <div
        id="game-over-screen"
        class="hidden absolute inset-0 pointer-events-auto flex items-center justify-center"
        style="background: linear-gradient(180deg, #7DD3FC 0%, #38BDF8 40%, #22D3EE 100%);"
      >
        <div
          class="absolute bottom-0 left-0 right-0 h-32"
          style="background: linear-gradient(180deg, #4ADE80 0%, #22C55E 50%, #16A34A 100%); border-radius: 50% 50% 0 0 / 30px 30px 0 0;"
        ></div>

        <div class="relative z-10 flex flex-col items-center text-center px-6">
          <h2
            class="text-5xl md:text-6xl font-bold mb-8"
            style="
              font-family: 'Fredoka One', 'Comic Sans MS', cursive;
              color: #FEF3C7;
              text-shadow: 3px 3px 0 #8B4513, 4px 4px 0 #5D3A1A, 0 6px 10px rgba(0,0,0,0.35);
            "
          >
            Game Over
          </h2>

          <div
            class="text-2xl md:text-3xl font-bold mb-8 px-6 py-3 rounded-full"
            style="
              font-family: 'Fredoka One', 'Comic Sans MS', cursive;
              color: #0f172a;
              background: rgba(255,255,255,0.85);
              box-shadow: 0 8px 20px rgba(0,0,0,0.2), inset 0 2px 4px rgba(255,255,255,0.9);
            "
          >
            Final Score: <span id="final-score">0</span>
          </div>

          <button
            id="restart-btn"
            class="px-12 py-4 rounded-full text-2xl font-bold text-white tracking-wide cursor-pointer transition-transform duration-150 hover:-translate-y-0.5 active:translate-y-1"
            style="
              background: linear-gradient(180deg, #4ADE80 0%, #22C55E 50%, #16A34A 100%);
              box-shadow: 0 6px 0 #15803D, 0 8px 15px rgba(0,0,0,0.3), inset 0 2px 4px rgba(255,255,255,0.4);
              text-shadow: 1px 1px 2px rgba(0,0,0,0.25);
            "
          >
            Try Again üçé
          </button>
        </div>
      </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
      // --- Game Constants & State ---
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // Game State
      let state = {
        isPlaying: false,
        score: 0,
        lives: 3,
        streak: 0,
        streakMultiplier: 1,
        gameTime: 0,
        lastTime: 0,
        width: 0,
        height: 0,
      };

      
      // Resize handling
      function resize() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + "px";
        canvas.style.height = window.innerHeight + "px";

        ctx.scale(dpr, dpr);

        state.width = window.innerWidth;
        state.height = window.innerHeight;
      }
      window.addEventListener("resize", resize);
      resize();

      // --- Main Game Loop Skeleton ---
      function loop(timestamp) {
        if (!state.lastTime) state.lastTime = timestamp;
        const dt = (timestamp - state.lastTime) / 1000;
        state.lastTime = timestamp;

        if (state.isPlaying) {
          update(dt);
          draw();
        }

        requestAnimationFrame(loop);
      }

      // --- Input Handling ---
      const input = {
        left: false,
        right: false,
        x: null, // For touch/mouse drag
      };

      window.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A")
          input.left = true;
        if (e.key === "ArrowRight" || e.key === "d" || e.key === "D")
          input.right = true;
      });

      window.addEventListener("keyup", (e) => {
        if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A")
          input.left = false;
        if (e.key === "ArrowRight" || e.key === "d" || e.key === "D")
          input.right = false;
      });

      // Touch/Mouse Drag
      function handleMove(clientX) {
        if (!state.isPlaying) return;
        input.x = clientX;
      }

      window.addEventListener("mousemove", (e) => {
        if (e.buttons === 1) handleMove(e.clientX); // Only drag if clicked
      });
      window.addEventListener(
        "touchmove",
        (e) => {
          e.preventDefault(); // Prevent scrolling
          handleMove(e.touches[0].clientX);
        },
        { passive: false }
      );

      window.addEventListener("touchstart", (e) => {
        handleMove(e.touches[0].clientX);
      });

      window.addEventListener("touchend", () => {
        input.x = null;
      });
      window.addEventListener("mouseup", () => {
        input.x = null;
      });

      // --- Entities ---
      class Player {
        constructor() {
          this.width = 100;
          this.height = 60;
          this.x = state.width / 2 - this.width / 2;
          this.y = state.height - this.height - 20;
          this.speed = 600; // pixels per second
          this.color = "#f59e0b"; // amber-500
        }

        update(dt) {
          // Keyboard Movement
          if (input.left) this.x -= this.speed * dt;
          if (input.right) this.x += this.speed * dt;

          // Mouse/Touch Follow (Direct positioning with lerp for smoothness)
          if (input.x !== null) {
            const targetX = input.x - this.width / 2;
            // Simple lerp for smooth drag following
            this.x += (targetX - this.x) * 15 * dt;
          }

          // Boundaries
          if (this.x < 0) this.x = 0;
          if (this.x + this.width > state.width)
            this.x = state.width - this.width;

          // Update Y position in case of resize
          this.y = state.height - this.height - 20;
        }

        draw(ctx) {
          // Basket Body (Trapezoid shape)
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.moveTo(this.x, this.y);
          ctx.lineTo(this.x + this.width, this.y);
          ctx.lineTo(this.x + this.width - 15, this.y + this.height);
          ctx.lineTo(this.x + 15, this.y + this.height);
          ctx.closePath();
          ctx.fill();

          // Basket Rim
          ctx.fillStyle = "#d97706"; // amber-600
          ctx.fillRect(this.x - 5, this.y, this.width + 10, 10);

          // Weave pattern details (optional polish)
          ctx.fillStyle = "rgba(0,0,0,0.1)";
          for (let i = 1; i < 4; i++) {
            ctx.fillRect(
              this.x + 10,
              this.y + (this.height / 4) * i,
              this.width - 20,
              2
            );
          }
        }
      }

      class Fruit {
        constructor(type, speedMultiplier) {
          this.type = type; // 'good' or 'bad'
          this.radius = 25;
          this.x =
            Math.random() * (state.width - this.radius * 2) + this.radius;
          this.y = -this.radius * 2;
          this.speed = (200 + Math.random() * 100) * speedMultiplier;
          this.rotation = 0;
          this.rotSpeed = (Math.random() - 0.5) * 4;
          this.markedForDeletion = false;

          // Visuals
          this.emoji =
            type === "good"
              ? ["üçé", "üçå", "üçá", "üçä", "üçì"][Math.floor(Math.random() * 5)]
              : ["üí£", "üß®", "ü•Ä", "ü™®"][Math.floor(Math.random() * 4)];
        }

        update(dt) {
          this.y += this.speed * dt;
          this.rotation += this.rotSpeed * dt;

          if (this.y > state.height + 50) {
            this.markedForDeletion = true;
            if (this.type === "good") {
              // Missed good fruit logic
              handleMiss();
            }
          }
        }

        draw(ctx) {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.rotation);

          ctx.font =
            '40px "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", sans-serif';
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          // White outline for high contrast
          ctx.lineWidth = 4;
          ctx.strokeStyle = "#ffffff";
          ctx.lineJoin = "round";
          ctx.strokeText(this.emoji, 0, 0);

          // Main emoji
          ctx.fillText(this.emoji, 0, 0);

          ctx.restore();
        }
      }

      let player;
      let fruits = [];
      let spawnTimer = 0;
      let spawnInterval = 1.5;

      function checkCollisions() {
        for (let fruit of fruits) {
          if (fruit.markedForDeletion) continue;

          // Simple Circle-Rectangle Collision
          // Find closest point on rectangle to circle center
          let testX = fruit.x;
          let testY = fruit.y;

          if (fruit.x < player.x) testX = player.x;
          else if (fruit.x > player.x + player.width)
            testX = player.x + player.width;

          if (fruit.y < player.y) testY = player.y;
          else if (fruit.y > player.y + player.height)
            testY = player.y + player.height;

          let distX = fruit.x - testX;
          let distY = fruit.y - testY;
          let distance = Math.sqrt(distX * distX + distY * distY);

          if (distance <= fruit.radius) {
            fruit.markedForDeletion = true;
            handleCatch(fruit);
          }
        }
      }

      // --- Audio System ---
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      const sounds = {
        catch: (streak) => {
          if (audioCtx.state === "suspended") audioCtx.resume();
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.connect(gain);
          gain.connect(audioCtx.destination);

          osc.type = "sine";
          // Pitch goes up with streak
          osc.frequency.setValueAtTime(400 + streak * 50, audioCtx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(
            800 + streak * 50,
            audioCtx.currentTime + 0.1
          );

          gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
          gain.gain.exponentialRampToValueAtTime(
            0.01,
            audioCtx.currentTime + 0.1
          );

          osc.start();
          osc.stop(audioCtx.currentTime + 0.1);
        },
        bad: () => {
          if (audioCtx.state === "suspended") audioCtx.resume();
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.connect(gain);
          gain.connect(audioCtx.destination);

          osc.type = "sawtooth";
          osc.frequency.setValueAtTime(150, audioCtx.currentTime);
          osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.3);

          gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
          gain.gain.exponentialRampToValueAtTime(
            0.01,
            audioCtx.currentTime + 0.3
          );

          osc.start();
          osc.stop(audioCtx.currentTime + 0.3);
        },
        miss: () => {
          if (audioCtx.state === "suspended") audioCtx.resume();
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.connect(gain);
          gain.connect(audioCtx.destination);

          osc.type = "triangle";
          osc.frequency.setValueAtTime(300, audioCtx.currentTime);
          osc.frequency.linearRampToValueAtTime(
            200,
            audioCtx.currentTime + 0.2
          );

          gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
          gain.gain.exponentialRampToValueAtTime(
            0.01,
            audioCtx.currentTime + 0.2
          );

          osc.start();
          osc.stop(audioCtx.currentTime + 0.2);
        },
      };

      // --- Particle System ---
      class Particle {
        constructor(x, y, color) {
          this.x = x;
          this.y = y;
          this.color = color;
          this.size = Math.random() * 5 + 2;
          this.speedX = (Math.random() - 0.5) * 10;
          this.speedY = (Math.random() - 0.5) * 10;
          this.life = 1.0;
          this.decay = Math.random() * 0.03 + 0.02;
        }

        update() {
          this.x += this.speedX;
          this.y += this.speedY;
          this.life -= this.decay;
          this.size *= 0.95;
        }

        draw(ctx) {
          ctx.globalAlpha = this.life;
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1.0;
        }
      }

      let particles = [];

      function spawnParticles(x, y, color, count = 10) {
        for (let i = 0; i < count; i++) {
          particles.push(new Particle(x, y, color));
        }
      }

      function handleCatch(fruit) {
        if (fruit.type === "good") {
          state.streak++;
          updateStreak();
          let points = 10 * state.streakMultiplier;
          state.score += points;
          sounds.catch(state.streakMultiplier);
          spawnParticles(fruit.x, fruit.y, "#fbbf24", 15); // Yellow particles

          // Floating text (simple implementation via particles or separate entity? Let's use particles for now or just UI update)
        } else {
          state.lives--;
          state.streak = 0;
          updateStreak();
          document.body.classList.add("shake");
          setTimeout(() => document.body.classList.remove("shake"), 500);
          sounds.bad();
          spawnParticles(fruit.x, fruit.y, "#ef4444", 20); // Red particles
        }
        updateUI();
        checkGameOver();
      }

      function handleMiss() {
        state.streak = 0;
        updateStreak();
        state.lives--;
        updateUI();
        checkGameOver();
        sounds.miss();
      }

      function updateStreak() {
        if (state.streak < 5) state.streakMultiplier = 1;
        else if (state.streak < 10) state.streakMultiplier = 2;
        else if (state.streak < 20) state.streakMultiplier = 3;
        else state.streakMultiplier = 4;
      }

      function updateUI() {
        document.getElementById("score").innerText = state.score;
        const livesEl = document.getElementById("lives");
        livesEl.innerText =
          state.lives <= 0 ? "üíîüíîüíî" : "‚ù§Ô∏è".repeat(Math.max(0, state.lives));
        document.getElementById("streak").innerText =
          "x" + state.streakMultiplier;

        // Streak bar width
        let percentage = Math.min(100, (state.streak / 20) * 100);
        document.getElementById("streak-bar").style.width = percentage + "%";
      }

      function checkGameOver() {
        if (state.lives <= 0) {
          state.isPlaying = false;
          document.getElementById("final-score").innerText = state.score;
          gameOverScreen.classList.remove("hidden");
        }
      }

      function update(dt) {
        state.gameTime += dt;

        // Difficulty Scaling
        // Speed increases with time
        let speedMultiplier = 1 + state.gameTime / 60;
        // Spawn rate increases
        spawnInterval = Math.max(0.4, 1.5 - state.gameTime / 40);

        // Spawning
        spawnTimer += dt;
        if (spawnTimer > spawnInterval) {
          spawnTimer = 0;
          let isBad = Math.random() < Math.min(0.3, 0.1 + state.gameTime / 100); // Cap bad items at 30%
          fruits.push(new Fruit(isBad ? "bad" : "good", speedMultiplier));
        }

        if (player) player.update(dt);

        fruits.forEach((f) => f.update(dt));

        // Update particles
        particles.forEach((p) => p.update());
        particles = particles.filter((p) => p.life > 0);

        checkCollisions();

        // Cleanup
        fruits = fruits.filter((f) => !f.markedForDeletion);
      }

      function draw() {
        ctx.clearRect(0, 0, state.width, state.height);

        // Background Gradient (match start screen sky)
        const skyGradient = ctx.createLinearGradient(0, 0, 0, state.height);
        skyGradient.addColorStop(0, "#7DD3FC");
        skyGradient.addColorStop(0.4, "#38BDF8");
        skyGradient.addColorStop(1, "#22D3EE");
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, state.width, state.height);

        // Ground strip at bottom
        const groundHeight = Math.max(100, state.height * 0.18);
        const groundGradient = ctx.createLinearGradient(
          0,
          state.height - groundHeight,
          0,
          state.height
        );
        groundGradient.addColorStop(0, "#4ADE80");
        groundGradient.addColorStop(0.5, "#22C55E");
        groundGradient.addColorStop(1, "#16A34A");
        ctx.fillStyle = groundGradient;
        ctx.beginPath();
        ctx.moveTo(0, state.height - groundHeight + 30);
        ctx.quadraticCurveTo(
          state.width / 2,
          state.height - groundHeight - 20,
          state.width,
          state.height - groundHeight + 30
        );
        ctx.lineTo(state.width, state.height);
        ctx.lineTo(0, state.height);
        ctx.closePath();
        ctx.fill();

        if (player) player.draw(ctx);
        fruits.forEach((f) => f.draw(ctx));
        particles.forEach((p) => p.draw(ctx));
      }

      // --- UI & Controls ---
      const startScreen = document.getElementById("start-screen");
      const gameOverScreen = document.getElementById("game-over-screen");
      const startBtn = document.getElementById("start-btn");
      const restartBtn = document.getElementById("restart-btn");

      function startGame() {
        state.isPlaying = true;
        state.score = 0;
        state.lives = 3;
        state.streak = 0;
        state.gameTime = 0;
        state.lastTime = 0;

        startScreen.classList.add("hidden");
        gameOverScreen.classList.add("hidden");

        player = new Player();
        fruits = [];
        particles = [];
        spawnTimer = 0;
        updateUI();
      }

      startBtn.addEventListener("click", startGame);
      restartBtn.addEventListener("click", startGame);



      function drawStartBasket() {
  const basketCanvas = document.getElementById('start-basket');
  if (!basketCanvas) return;
  
  const bCtx = basketCanvas.getContext('2d');
  const previewBasket = new Player();
  previewBasket.width = 130;
  previewBasket.height = 80;
  previewBasket.x = 10;
  previewBasket.y = 10;
  previewBasket.draw(bCtx);
}

// Call it to show basket on start screen
drawStartBasket();

      // Start loop
      requestAnimationFrame(loop);
    </script>
  </body>
</html>
